name: Deploy Backend

on:
  push:
    branches:
      - develop
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Set environment variables
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "ENV=prod" >> $GITHUB_ENV
            echo "BACKEND_PORT=8080" >> $GITHUB_ENV
            echo "MYSQL_PORT=3306" >> $GITHUB_ENV
            echo "DB_NAME=zerogravity_prod" >> $GITHUB_ENV
            echo "DEPLOY_TARGET=Production (api.zerogv.com)" >> $GITHUB_ENV
          else
            echo "ENV=dev" >> $GITHUB_ENV
            echo "BACKEND_PORT=8081" >> $GITHUB_ENV
            echo "MYSQL_PORT=3307" >> $GITHUB_ENV
            echo "DB_NAME=zerogravity_dev" >> $GITHUB_ENV
            echo "DEPLOY_TARGET=Development (api-dev.zerogv.com)" >> $GITHUB_ENV
          fi

      - name: Deploy to OCI server
        uses: appleboy/ssh-action@v1.0.3
        env:
          ENV: ${{ env.ENV }}
          BACKEND_PORT: ${{ env.BACKEND_PORT }}
          MYSQL_PORT: ${{ env.MYSQL_PORT }}
          DB_NAME: ${{ env.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
        with:
          host: ${{ secrets.OCI_HOST }}
          username: ubuntu
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: ENV,BACKEND_PORT,MYSQL_PORT,DB_NAME,DB_USER,DB_PASSWORD,JWT_SECRET,GEMINI_API_KEY,MYSQL_ROOT_PASSWORD
          script: |
            # Navigate to app directory (create if doesn't exist)
            mkdir -p /home/ubuntu/app
            cd /home/ubuntu/app

            # Clone repo if not exists, otherwise pull latest code
            if [ ! -d ".git" ]; then
              echo "Git repository not found. Cloning from GitHub..."
              git clone https://github.com/zerogravity-project/zerogravity-backend.git .
              if [ "$ENV" = "prod" ]; then
                git checkout main
              else
                git checkout develop
              fi
            else
              # Pull latest code (use reset to avoid divergence issues)
              git fetch origin
              if [ "$ENV" = "prod" ]; then
                git reset --hard origin/main
              else
                git reset --hard origin/develop
              fi
            fi

            # Verify current commit
            echo "‚úÖ Deployment commit: $(git log -1 --format='%h %s')"

            # Create .env file
            cat > .env << EOF
            ENV=$ENV
            BACKEND_PORT=$BACKEND_PORT
            MYSQL_PORT=$MYSQL_PORT
            DB_NAME=$DB_NAME
            DB_USER=$DB_USER
            DB_PASSWORD=$DB_PASSWORD
            JWT_SECRET=$JWT_SECRET
            GEMINI_API_KEY=$GEMINI_API_KEY
            MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD
            EOF

            # Step 1: Backup current image (if it exists)
            echo "üîÑ Backing up current image..."
            if docker ps --filter "name=zerogv-backend-$ENV" --format "{{.Names}}" | grep -q "zerogv-backend-$ENV"; then
              docker commit zerogv-backend-$ENV zerogv-backend:${ENV}-backup || true
              echo "‚úÖ Backup created: zerogv-backend:${ENV}-backup"
            else
              echo "‚ÑπÔ∏è  No existing container to backup (first deployment)"
            fi

            # Step 2: Stop current containers
            docker compose -p zerogv-${ENV} down || true

            # Step 3: Build and start new containers
            echo "üöÄ Building and deploying new version..."
            docker compose -p zerogv-${ENV} up -d --build

            # Step 4: Health check with validation
            echo "‚è≥ Waiting for backend to be healthy (max 150 seconds)..."
            HEALTH_CHECK_PASSED=false
            for i in {1..30}; do
              # Check if container is running first
              if ! docker ps --filter "name=zerogv-backend-$ENV" --format "{{.Names}}" | grep -q "zerogv-backend-$ENV"; then
                echo "‚ùå Container is not running! Deployment failed."
                break
              fi

              # Check health status (using jq for reliable JSON parsing)
              HEALTH_STATUS=$(docker inspect zerogv-backend-$ENV 2>/dev/null | jq -r '.[0].State.Health.Status // "starting"')

              if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "‚úÖ Backend is healthy! Deployment successful."
                HEALTH_CHECK_PASSED=true
                break
              elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
                echo "‚ùå Backend is unhealthy! Deployment failed."
                break
              fi

              echo "Attempt $i/30: Backend status: ${HEALTH_STATUS:-starting}, waiting..."
              sleep 5
            done

            # Step 5: Rollback if health check failed
            if [ "$HEALTH_CHECK_PASSED" = false ]; then
              echo "‚ùå DEPLOYMENT FAILED: Health check did not pass"
              echo "üîÑ Rolling back to previous version..."

              # Stop failed containers
              docker compose -p zerogv-${ENV} down

              # Check if backup exists
              if docker images | grep -q "zerogv-backend.*${ENV}-backup"; then
                echo "üì¶ Restoring backup image..."
                docker tag zerogv-backend:${ENV}-backup zerogv-backend:latest
                docker compose -p zerogv-${ENV} up -d
                echo "‚úÖ Rollback completed. Previous version restored."
                exit 1
              else
                echo "‚ö†Ô∏è  ERROR: No backup image found for rollback!"
                echo "This may be the first deployment. Manual intervention required."
                exit 1
              fi
            fi

            # Step 6: Cleanup old backup image
            echo "üßπ Cleaning up old backup..."
            docker images | grep "zerogv-backend.*${ENV}-backup" | awk '{print $3}' | xargs -r docker rmi || true
            echo "‚úÖ Cleanup completed"

            # Step 7: Deploy Nginx configuration
            ./scripts/deploy-nginx.sh

            # Step 8: Show container status
            docker ps | grep zerogv

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        env:
          ENV: ${{ env.ENV }}
          BACKEND_PORT: ${{ env.BACKEND_PORT }}
        with:
          host: ${{ secrets.OCI_HOST }}
          username: ubuntu
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: ENV,BACKEND_PORT
          script: |
            # Check health endpoint
            echo "Checking health endpoint..."
            curl -f http://localhost:$BACKEND_PORT/actuator/health || exit 1
            echo "Health check passed!"

            # Warm-up: Initialize DB connection pool and DispatcherServlet
            echo "Warming up application..."
            sleep 2
            curl -X POST http://localhost:$BACKEND_PORT/auth/verify \
              -H "Content-Type: application/json" \
              -d '{"provider":"WARMUP","providerId":"warmup-test","email":"warmup@test.com","name":"Warmup","image":""}' \
              -s -o /dev/null -w "Warm-up request: HTTP %{http_code} (took %{time_total}s)\n" || true
            echo "‚úÖ Application warmed up and ready!"

      - name: Deployment summary
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "Environment: ${{ env.ENV }}"
          echo "Target: ${{ env.DEPLOY_TARGET }}"
          echo "Backend Port: ${{ env.BACKEND_PORT }}"
          echo "MySQL Port: ${{ env.MYSQL_PORT }}"
